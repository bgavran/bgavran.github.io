<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-PWZE1HYS87"></script>
        <script>
         window.dataLayer = window.dataLayer || [];
         function gtag(){dataLayer.push(arguments);}
         gtag('js', new Date());

         gtag('config', 'G-PWZE1HYS87');
        </script>

        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="author" content="Bruno Gavranovic" />
        <meta name="viewport" content="width=device-width" />
        <meta http-equiv="Cache-Control" content="max-age=86400, must-revalidate" />
        <title>Lenses to the left of me, Prisms to the right</title>
        <script src="../css/jquery.js"></script>
        <script src="../css/selectfile.js"></script>
        <link rel="stylesheet" type="text/css" title="hakyll_theme" href="../css/theprofessional.css" />
        <link href="https://fonts.googleapis.com/css?family=Titillium+Web" rel="stylesheet">

        <!-- MathJax font size adjustment -->
        <style>
            mjx-container {
                font-size: 80% !important;
            }

            /* Scale TikZ diagrams uniformly */
            .page svg {
                transform: scale(1.2) !important;
                transform-origin: center !important;
            }

            /* Improve code blocks */
            pre, code {
                background-color: #f8f9fa;
                border: 1px solid #e1e4e8;
                border-radius: 3px;
                font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
                font-size: 0.9em;
            }

            pre {
                padding: 1em;
                overflow-x: auto;
            }

            code {
                padding: 0.2em 0.4em;
            }

            pre code {
                background: none;
                border: none;
                padding: 0;
            }
        </style>

        <!-- MathJax for regular math -->
        <script>
            MathJax = {
                tex: {
                    macros: {
                        coloneqq: '\\mathrel{\\vcenter{:}}=',
                        enskip: '\\hspace{0.5em}'
                    }
                }
            };
        </script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

        <!-- TikZJax for TikZ diagrams -->
        <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
        <script src="https://tikzjax.com/v1/tikzjax.js"></script>
    </head>
    <body>
        <div class="highbar">&nbsp;</div>
        <div class="container-gallery">
        <div id="content" class="inside">

        <div id="header">
          <div class="box">
            <div id="logo" class="name">
                <h2><pageTitle><a href="../">Bruno Gavranović</a></pageTitle></h2>
            </div>
            <div id="navigation" class="pageslinks">
              <nav class="menuNav">
                <div class="menuItems">
                <a href="../" class="posts/2022-01-05-lenses-to-the-left-of-me.md">Home</a>
                <a href="../archive.html" class="posts/2022-01-05-lenses-to-the-left-of-me.md">Posts</a>
                <a href="../papers.html" class="posts/2022-01-05-lenses-to-the-left-of-me.md">Papers</a>
                <a href="../research_programme.html" class="posts/2022-01-05-lenses-to-the-left-of-me.md">Research Programme</a>
                <a href="../about.html" class="posts/2022-01-05-lenses-to-the-left-of-me.md">About</a>
		<!-- <a href="/contact.html" class="posts/2022-01-05-lenses-to-the-left-of-me.md">Contact</a> -->
                </div>
              </nav>
            </div>
        </div>
        </div>
            <script src="https://unpkg.com/commentbox.io/dist/commentBox.min.js"></script>

<div class="info">
    Posted on January  5, 2022
    
</div>

<h1 id="lenses-to-the-left-of-me-prisms-to-the-right">Lenses to the left of me, Prisms to the right</h1>
<p>There’s an interesting way to think about lenses and prisms. Lenses model processes that perform internal computation <em>and</em> interact with the environment. Prisms model processes that perform internal computation <em>or</em> interact with the environment. Let me explain what I mean.</p>
<p>A lens <span class="math inline">\((A, A') \to (B, B')\)</span> is usually thought of as a pair of maps <span class="math inline">\(get : A \to B\)</span> and <span class="math inline">\(put : A \times B' \to A'\)</span>. This is the classic presentation of a lens. Instead, here we’ll use the <em>coend</em> representation of which is more symmetric. It’s defined in terms of two maps of type <span class="math inline">\(f : A \to A \times B\)</span> and <span class="math inline">\(b : A \times B' \to A'\)</span>, meaning <em>forward</em> and <em>backward</em>, respectively. For any lens defined in terms of <span class="math inline">\(get\)</span> and <span class="math inline">\(put\)</span> maps, we can recast it to the coend form: define <span class="math inline">\(f\)</span> as the composite <span class="math inline">\(A \xrightarrow{\Delta_A} A \times A \xrightarrow{A \times get} A \times B\)</span> , while <span class="math inline">\(b = put\)</span>. This is the representation of lens as an optic, and it makes explicit the fact that the forward part of the lens saves an <em>internal state of type <span class="math inline">\(A\)</span></em>. In the image below, the forward map <span class="math inline">\(f\)</span> is the gray box and the internal state is drawn as the vertical wire (this is also called the “residual”). The dot is the copy map <span class="math inline">\(\Delta_A\)</span>.</p>
<center>
<img src="../images/lens.png" alt="Lens as an optic" width="600" />
</center>
<p>We can imagine a particle flowing in this lens, as an input of type <span class="math inline">\(A\)</span>. A lens takes in this input and does two things in parallel in the forward pass: it copies it down on the vertical wire (residual/internal state) <em>and</em> it also uses the map <span class="math inline">\(get\)</span> to turn it into an output <span class="math inline">\(B\)</span>.
Then, this output <span class="math inline">\(B\)</span> is turned into a “response” <span class="math inline">\(B'\)</span> by the environment (not drawn), and on the backward pass via the <span class="math inline">\(put\)</span> map it’s turned back into <span class="math inline">\(A'\)</span>. In other words, in this lens we can trace out “two paths” the data flows through starting from <span class="math inline">\(A\)</span> and ending at <span class="math inline">\(A'\)</span>: it goes through the residual (which is in this case also of type <span class="math inline">\(A\)</span>) <em>and</em> it goes through both <span class="math inline">\(B\)</span> and <span class="math inline">\(B'\)</span>.</p>
<center>
<img src="../images/lens_traces.gif" alt="Lens two traces" width="600" />
</center>
<p>We can think of this as a “conjunctive” data flow: both paths are traversed. The lens computes some internal state <em>and</em> interacts with the environment. This is useful for <a href="https://arxiv.org/abs/2103.01931">machine learning</a> (where we want to remember which point we’re differentiating <em>with respect to</em> on the backward pass) and in <a href="https://arxiv.org/abs/1603.04641">game theory</a> (where we want to remember the state for which we’re going to receive a payoff for).</p>
<p>A prism, on the other hand, is characterized by a <em>disjunctive</em> data flow. Starting from <span class="math inline">\(A\)</span>, a prism <em>routes</em> the data to go one of two ways: either inside through the residual <em>or</em> outside into the environment through <span class="math inline">\(B\)</span> and <span class="math inline">\(B'\)</span>. We see this animated below.</p>
<center>
<p float="left">
<img src="../images/prism_default_resized.gif" alt="Prism trace" width="400" />
<img src="../images/prism_env_resized.gif" alt="Prism trace" width="400" />
</p>
</center>
<p>More precisely, a prism is <span class="math inline">\((A, A') \to (B, B')\)</span> is a pair of two maps <span class="math inline">\(match : A \to A' + B\)</span> and <span class="math inline">\(build : B' \to A'\)</span>. This is the classic presentation of a prism. As we’ll now see, it too has a more symmetric coend representation. It’s defined in the analogous way - in terms of two maps <span class="math inline">\(f : A \to A' + B\)</span> and <span class="math inline">\(b : A' + B' \to A'\)</span> standing for <em>forward</em> and <em>backward</em>. For any prism defined in terms of <span class="math inline">\(match\)</span> and <span class="math inline">\(build\)</span> maps, we can recast it to the coend form by setting <span class="math inline">\(f = match\)</span> and setting <span class="math inline">\(b\)</span> to the composite <span class="math inline">\(A' + B' \xrightarrow{A' + build} A' + A' \xrightarrow{\nabla_A} A\)</span>. In the image below we can see how the prism is an upside-down, mirror image of a lens.</p>
<center>
<img src="../images/prism.png" alt="Prism as an optic" width="600" />
</center>
<p>We can also imagine a particle flowing through a prism. A prism takes in an input <span class="math inline">\(A\)</span>, checks for some condition, and allows the environment to execute some computation only if that condition is true. This computation is of type <span class="math inline">\(B \to B'\)</span>. That is, the environment takes in a <span class="math inline">\(B\)</span> that the prism produced and returns a <span class="math inline">\(B'\)</span> which the prism receives. The prism then has to translate that <span class="math inline">\(B'\)</span> into an <span class="math inline">\(A'\)</span>, i.e. it has to know how to translate the answer from the environment into the type that it would’ve ended up with if the condition had been false.</p>
<p>This shows that that unlike a lens, a prism routes data to one of two ways: <em>either</em> through the residual into <span class="math inline">\(A'\)</span>, <em>or</em> through the environment. These two branches of computation are shown as two animations above. For each input of type <span class="math inline">\(A\)</span>, only one of them will get executed. Prisms are quite often used in parsing. In game theory, we would use prisms if we want to allow agents to stop playing a game.</p>
<p>I find this operational perspective of lenses and prisms enlightening. If we think of lenses and prisms as little machines, then lenses are machines that always query the environment as they operate. Prisms, on the other hand, only sometimes query the environment, depending on the values of certain variables in their internals.</p>
<h2 id="here-i-am-stuck-in-an-affine-traversal-with-you">Here I am, stuck in an Affine Traversal with you</h2>
<p>Can we combine lenses and prisms? Can we model a process that has both disjunctive and conjunctive data flows? The answer is yes, and we get something that’s called an <em>affine traversal</em>. To understand it, let’s go back to the formal definition.</p>
<p>Both lenses and prisms are optics, and optics have a neat coend representation. Given a symmetric monoidal category <span class="math inline">\(\mathcal{C}\)</span>, the hom-object of optics is defined as follows:</p>
<center>
<span class="math display">\[\mathbf{Optic}(\mathcal{C})((A, A'), (B, B')) = \int^M \mathcal{C}(A, M \otimes B) \times \mathcal{C}(M \otimes B', A')\]</span>
</center>
<p>Lenses fall out when <span class="math inline">\(\mathcal{C}\)</span> is a cartesian monoidal category, and prisms fall out when <span class="math inline">\(\mathcal{C}\)</span> is a cocartesian monoidal category. So how do we compose lenses and prisms?</p>
<center>
<img src="../images/affine_traversal_transparent.png" alt="Lens + Prism = Affine Traversal" width="450" />
</center>
<p>Since both are given by some monoidal categories, we’d expect that affine traversals are given by a monoidal category too.
But it’s not clear how to compose two monoidal categories. What would we even expect the result to be? As always, making sure we understand what it is that we want to do will lead us to the answer. And if we think, we can realise that it’s not the case that we want to treat these as <em>just</em> monoidal categories.</p>
<p>In the above definition, looking at the operator <span class="math inline">\(\otimes\)</span> (which appears twice), its left operand <span class="math inline">\(M\)</span> has different semantics than its right operand. The object <span class="math inline">\(M\)</span> is <em>private</em> data of an optic hidden from the outside world, while objects <span class="math inline">\(B\)</span> and <span class="math inline">\(B'\)</span> are “ports” available to the outside world. Even more, if we think about the underlying functor of the monoidal category <span class="math inline">\(\otimes : \mathcal{C} \times \mathcal{C} \to \mathcal{C}\)</span>, there’s nothing in the definition of the optics that requires the first argument to be the same as the second. The private information <span class="math inline">\(M\)</span> can be of different type than <span class="math inline">\(B\)</span> and <span class="math inline">\(B'\)</span> which are available to the outside world.</p>
<p>This brings us to the world of <a href="http://nlab-pages.s3.us-east-2.amazonaws.com/nlab/show/actegory">actegories</a>. They have a slick definition. Let <span class="math inline">\(\mathcal{M}\)</span> be a monoidal category, and <span class="math inline">\(\mathcal{C}\)</span> just a category. A <span class="math inline">\(\mathcal{M}\)</span>-actegory <span class="math inline">\(\mathcal{C}\)</span> is a strong monoidal functor <span class="math inline">\(\bullet : \mathcal{M} \to [\mathcal{C}, \mathcal{C}]\)</span>. Uncurrying <span class="math inline">\(\bullet\)</span> we can represent actegories in a more familiar form, as a functor of type <span class="math inline">\(\mathcal{M} \times \mathcal{C} \to \mathcal{C}\)</span> plus some equations. This looks similar to a monoidal category, and the extra level of generality will be needed to represent affine traversals.</p>
<p>An actegory is like a <a href="http://nlab-pages.s3.us-east-2.amazonaws.com/nlab/show/para+construction">parameterised map</a>. A <span class="math inline">\(\mathcal{M}\)</span>-actegory <span class="math inline">\(\mathcal{C}\)</span> is a map <span class="math inline">\(\mathcal{C} \to \mathcal{C}\)</span> parameterised by <span class="math inline">\(\mathcal{M}\)</span>. And parameterised maps have a well-defined composition rule. A <span class="math inline">\(P\)</span> parameterised map <span class="math inline">\(A \to B\)</span> and a <span class="math inline">\(Q\)</span>-parameterised map <span class="math inline">\(B \to C\)</span> can be plugged together to obtain a <span class="math inline">\(P \otimes Q\)</span>-parameterised map <span class="math inline">\(A \to C\)</span>, as animated below.</p>
<center>
<img src="../images/para_comp.gif" alt="Composition of parameterized maps" width="600" />
</center>
<p>Every symmetric monoidal category <span class="math inline">\(\mathcal{C}\)</span> is a <span class="math inline">\(\mathcal{C}\)</span>-actegory <span class="math inline">\(\mathcal{C}\)</span>, which means we have a clear way of composing lenses and prisms – as actegories! Let me spell it out.</p>
<p>A cartesian monoidal category is a <span class="math inline">\(\mathcal{C}\)</span>-parameterised map <span class="math inline">\(\mathcal{C} \to \mathcal{C}\)</span>. A cocartesian monoidal category is a <span class="math inline">\(\mathcal{C}\)</span>-parameterised map <span class="math inline">\(\mathcal{C} \to \mathcal{C}\)</span>. Composing them as parameterised maps, we obtain a <span class="math inline">\(\mathcal{C} \times \mathcal{C}\)</span>-parameterised map <span class="math inline">\(\mathcal{C} \to \mathcal{C}\)</span>.
This is a <span class="math inline">\(\mathcal{C} \times \mathcal{C}\)</span>-actegory <span class="math inline">\(\mathcal{C}\)</span>, i.e. a strong monoidal functor <span class="math inline">\(AF : \mathcal{C} \times \mathcal{C} \to [\mathcal{C}, \mathcal{C}]\)</span>.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> Fixing some parameters <span class="math inline">\((C, D) : \mathcal{C} \times \mathcal{C}\)</span>, what does the resulting functor <span class="math inline">\(AF(C, D) : \mathcal{C} \to \mathcal{C}\)</span> do? It takes some object <span class="math inline">\(B\)</span> to <span class="math inline">\(C + D \times B\)</span>.
If we unpack the definition of optics for this actegory, we recover the affine traversal defined <a href="https://arxiv.org/abs/2001.07488">Profunctor Optics: A Categorical Update</a> (Sec. 3.2.1).</p>
<p>This seems pretty neat, but what does an affine traversal <em>actually do</em>? Lenses compute an internal state <em>and</em> interact with the environment. Prisms compute an internal state <em>or</em> interact with the environment. Can we interpret an affine traversal in a similar way? The answer is yes. The first thing we have to note is that unlike lenses and prisms, the affine traversal is parameterised by a <em>pair</em> of private objects <span class="math inline">\((C, D) : \mathcal{C} \times \mathcal{C}\)</span>. This means that we’ll have a prism-like internal state <span class="math inline">\(C\)</span> and a lens-like internal state <span class="math inline">\(D\)</span>. Looking at the coend below</p>
<center>
<span class="math inline">\(\int^{C, D} \mathcal{C}(A, C + D \times B) \times \mathcal{C}(C + D \times B', A')\)</span>
</center>
<p>we can see that an affine traversal can do either one, but not both of these things:</p>
<ol type="1">
<li>Compute an internal state <span class="math inline">\(C\)</span></li>
<li>Compute an internal state <span class="math inline">\(D\)</span> <em>and</em> interact with the environment</li>
</ol>
<p>While technical derivations are available in the aforementioned paper, the high-level intuitions I presented here don’t seem to be. I find them useful, since they give an operational view of the affine traversal. We can also easily see how to recover prisms (by setting <span class="math inline">\(D = I\)</span>) and lenses (by setting <span class="math inline">\(C = I\)</span>).</p>
<h2 id="conclusions">Conclusions</h2>
<p>It’s been known for a while that affine traversals arise as compositions of lenses and prisms. What I couldn’t find in the literature was the definition of this composition operator, as well as a more detailed operational view. The perspective of lenses and prisms as processes that either <em>make us</em> query the environment, or <em>allow us to query the environment</em> was invaluable, and my key to understanding affine traversals.</p>
<p>This unlocks more questions. All optics in <a href="https://arxiv.org/abs/2001.07488">Profunctor Optics: A Categorical Update</a> are defined using actegories, and actegories can be composed. Can we use this method to come up with new types of optics? In this blog post we talked about the affine traversal, but can we recover <em>the traversal</em> as a limit of some infinite sequence of composition? Are there some even more exotic types of optics, other than kaleidoscopes, glasses and grates?</p>
<p>And lastly, it’s well known that lenses can be used to help us model all sorts of interaction protocols (<a href="https://arxiv.org/abs/2103.01931">1</a>, <a href="https://arxiv.org/abs/1903.03671">2</a>, <a href="https://arxiv.org/abs/1910.03656">3</a>). But prisms, affine traversals, and the rest of the optical gadgets do not appear as often in theories of interaction protocols, nor in machine learning or game theory. And it seems they ought to be, because they allow us to describe important kinds of systems: those with the ability to choose whether to execute some code or not. Those, especially in machine learning, are becoming more and more important.</p>
<p><br>
<br></p>
<p>Thanks to <a href="https://ievacepaite.com/">Ieva Čepaitė</a> and <a href="https://twitter.com/dailectic">David Orion Girardo</a> for a read-through of this post.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>While we can easily obtain the functor <span class="math inline">\(AF : \mathcal{C} \times \mathcal{C} \to [\mathcal{C}, \mathcal{C}]\)</span>, showing it is strong monoidal will require a distributive law between the two underlying actegories.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

<div class="commentbox"></div>


<script>
commentBox('5769281040023552-proj');
</script>

        <div id="footer">
          <div class="inside">
            Licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/"> CC BY-SA 4.0</a>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
            The theme originates in the <a href="http://katychuang.com/hakyll-cssgarden/gallery/">Hakyll-CSSGarden</a>.
          </div>
        </div>

          </div>
        </div>
    </body>
</html>
