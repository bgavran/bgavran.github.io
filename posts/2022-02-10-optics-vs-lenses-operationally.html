<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-PWZE1HYS87"></script>
        <script>
         window.dataLayer = window.dataLayer || [];
         function gtag(){dataLayer.push(arguments);}
         gtag('js', new Date());

         gtag('config', 'G-PWZE1HYS87');
        </script>

        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="author" content="Bruno Gavranovic" />
        <meta name="viewport" content="width=device-width" />
        <meta http-equiv="Cache-Control" content="max-age=86400, must-revalidate" />
        <title>Optics vs Lenses, Operationally</title>
        <script src="../css/jquery.js"></script>
        <script src="../css/selectfile.js"></script>
        <link rel="stylesheet" type="text/css" title="hakyll_theme" href="../css/theprofessional.css" />
        <link href="https://fonts.googleapis.com/css?family=Titillium+Web" rel="stylesheet">

        <!-- MathJax font size adjustment -->
        <style>
            mjx-container {
                font-size: 80% !important;
            }

            /* Scale TikZ diagrams uniformly */
            .page svg {
                transform: scale(1.2) !important;
                transform-origin: center !important;
            }

            /* Improve code blocks */
            pre, code {
                background-color: #f8f9fa;
                border: 1px solid #e1e4e8;
                border-radius: 3px;
                font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
                font-size: 0.9em;
            }

            pre {
                padding: 1em;
                overflow-x: auto;
            }

            code {
                padding: 0.2em 0.4em;
            }

            pre code {
                background: none;
                border: none;
                padding: 0;
            }
        </style>

        <!-- MathJax for regular math -->
        <script>
            MathJax = {
                tex: {
                    macros: {
                        coloneqq: '\\mathrel{\\vcenter{:}}=',
                        enskip: '\\hspace{0.5em}'
                    }
                }
            };
        </script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

        <!-- TikZJax for TikZ diagrams -->
        <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
        <script src="https://tikzjax.com/v1/tikzjax.js"></script>
    </head>
    <body>
        <div class="highbar">&nbsp;</div>
        <div class="container-gallery">
        <div id="content" class="inside">

        <div id="header">
          <div class="box">
            <div id="logo" class="name">
                <h2><pageTitle><a href="../">Bruno Gavranović</a></pageTitle></h2>
            </div>
            <div id="navigation" class="pageslinks">
              <nav class="menuNav">
                <div class="menuItems">
                <a href="../" class="posts/2022-02-10-optics-vs-lenses-operationally.md">Home</a>
                <a href="../archive.html" class="posts/2022-02-10-optics-vs-lenses-operationally.md">Posts</a>
                <a href="../papers.html" class="posts/2022-02-10-optics-vs-lenses-operationally.md">Papers</a>
                <a href="../research_programme.html" class="posts/2022-02-10-optics-vs-lenses-operationally.md">Research Programme</a>
                <a href="../about.html" class="posts/2022-02-10-optics-vs-lenses-operationally.md">About</a>
		<!-- <a href="/contact.html" class="posts/2022-02-10-optics-vs-lenses-operationally.md">Contact</a> -->
                </div>
              </nav>
            </div>
        </div>
        </div>
            <script src="https://unpkg.com/commentbox.io/dist/commentBox.min.js"></script>

<div class="info">
    Posted on February 10, 2022
    
</div>

<h1 id="optics-vs-lenses-operationally">Optics vs Lenses, Operationally</h1>
<p>(Update: This blog post has been turned into a <a href="https://arxiv.org/abs/2209.09351">paper</a> and a <a href="https://www.youtube.com/watch?v=BNHVySBzR3M">talk</a>.)</p>
<p>I’ve been thinking <a href="https://www.brunogavranovic.com/posts/2022-01-05-lenses-to-the-left-of-me.html">a lot</a> about lenses and optics. They’re both abstract gadgets that model various sorts of bidirectional processes. They are found in <a href="https://arxiv.org/abs/2103.01931">machine learning</a>, <a href="https://arxiv.org/abs/1603.04641">game theory</a>, <a href="https://arxiv.org/abs/2111.10968">database systems</a>, and so on. While optics are more general, it’s understood that they’re equivalent to lenses in the special case of a cartesian monoidal category <span class="math inline">\(\mathcal{C}\)</span>. In this blog post I’ll explain how this equivalence is denotational in nature, and the result of erasure of important operational data. Even more, sometimes it’s said that lenses are something we can simplify optics to. I’ll try to convey how this is misleading – concrete lenses don’t reduce any complexity; they just shove it under the rug.</p>
<p>Let’s see what that means.</p>
<h2 id="lenses-are-optics-with-one-choice-removed">Lenses are optics with one choice removed</h2>
<p>A lens <span class="math inline">\((A, A') \to (B, B')\)</span> is usually presented of as a pair of maps <span class="math inline">\(get : A \to B\)</span> and <span class="math inline">\(put : A \times B' \to A'\)</span>, thought of as the <em>forward</em> and <em>backward</em> map.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<center>
<p float="left">
<img src="../images/lens.png" alt="A lens" width="400" />
<img src="../images/lens_traces.gif" alt="Data flow through a lens" width="400" />
</p>
</center>
<p>We can imagine a particle flowing in this lens, starting from the input of type <span class="math inline">\(A\)</span>. A lens takes in this input and produces two things: a copy of it (sent down the vertical wire, where the operation of copying is drawn as a black dot) and the output <span class="math inline">\(B\)</span> (via the <span class="math inline">\(get\)</span> map). This is the <em>forward pass</em> of the lens.
Then, this output <span class="math inline">\(B\)</span> is turned into a “response” <span class="math inline">\(B'\)</span> by the environment (not drawn). This lands us in the <em>backward pass</em> of the lens, where it consumes two things: the response <span class="math inline">\(B'\)</span> and the previously saved copy of the input on the vertical wire, turning them back into <span class="math inline">\(A'\)</span>.</p>
<p>A lens has an inside and an outside. The outside are the ports <span class="math inline">\((A, A')\)</span> and <span class="math inline">\((B, B')\)</span>. These ports are the interface to which other lenses connect. The inside is the vertical wire whose type is <span class="math inline">\(A\)</span>. The vertical wire is the internal state of the lens (sometimes also called the <em>residual</em>) - mediating the transition between the forward and the backward pass.</p>
<center>
<img src="../images/lens_residual.png" alt="Lens residual made explicit" width="600" />
</center>
<p>In the lens literature, the notion of residual / internal state has not been reified. That is, when you define a lens, the type of the internal state / residual is something you have no control over. No matter what <span class="math inline">\(get\)</span> and <span class="math inline">\(put\)</span> map you write, the internal state will always be of the same type as the domain of <span class="math inline">\(get\)</span>. What flows through the internal state really won’t be any different than what flows in through the top-left input of the lens. This is important, so I’ll bold it.</p>
<center>
<strong>The type of the internal state of a lens <span class="math inline">\((A, A') \to (B, B')\)</span> is always equal to <span class="math inline">\(A\)</span>.</strong>
</center>
<p>With optics you’re in control. The internal state is explicit data that can be manipulated at will, and doesn’t necessarily have to equal the top-left input. That is,</p>
<center>
<strong>Optics reify the notion of the internal state of a bidirectional process.</strong>
</center>
<p>Let’s have a closer look. An optic <span class="math inline">\((A, A') \to (B, B')\)</span> is defined by three things. We need to pick a type <span class="math inline">\(M : \mathcal{C}\)</span> for the internal state, the forward map <span class="math inline">\(f : A \to M \times B\)</span>, and the backward map <span class="math inline">\(b : M \times B' \to A'\)</span>. This is in contrast to a lens which was defined by two things (maps <span class="math inline">\(get\)</span> and <span class="math inline">\(put\)</span>).</p>
<center>
<img src="../images/optic_residual.png" alt="An optic" width="600" />
</center>
<p>In the image above we see that there’s no <span class="math inline">\(get\)</span> map anymore, it’s been abstracted away. We’re also free <em>not</em> to copy the input <span class="math inline">\(A\)</span> down the vertical wire. But we can if we want to. We get lenses as special cases of optics by setting <span class="math inline">\(M = A\)</span>, <span class="math inline">\(f = \Delta_A ; (A \times g)\)</span> <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, and <span class="math inline">\(b = put\)</span>. We can also do more things. If our category is closed, we can form linear lenses. By setting the internal state to be a function space <span class="math inline">\(M = [B', A']\)</span>, the necessary type of forward map becomes <span class="math inline">\(A \to B \times [B', A']\)</span>. This is precisely the type of any linear lens. The type of backward map becomes <span class="math inline">\([B', A'] \times B' \to A'\)</span> for which we have a canonical term - the map <span class="math inline">\(eval : [B', A'] \times B' \to A'\)</span>.</p>
<p>Unlike with lenses, the type of the residual <span class="math inline">\(M\)</span> is hidden from the environment. The environment has no way of knowing what kind of internal computation the optic is performing. All the environment can interact with are the ports <span class="math inline">\((A, A')\)</span>, <span class="math inline">\((B, B')\)</span>. I think of it like a black-box system: we can still interact with the system from the outside through an interface, but there are wires inside the system that we can’t access.</p>
<p>Now, you might say - why does the choice of the residual matter? If residual is the internal state I don’t have access to, how does it impact me? No matter what residual and optic I choose, if I’m in a cartesian monoidal category, there’s going to be a lens that it’s equivalent to, and I can work with that lens. And you’d be right! I even <a href="https://twitter.com/bgavran3/status/1484197859205566464">animated this process</a>:</p>
<center>
<img src="../images/optic_to_lens.gif" alt="Lens as an optic" width="700" />
</center>
<p>However, this is only correct denotationally. Operationally, there’s a world of difference. This can most readily be seen by studying how lenses and optics compose.</p>
<h2 id="lenses-trade-simplicity-of-presentation-for-complexity-of-composition">Lenses trade simplicity of presentation for complexity of composition</h2>
<p>Lenses have a different composition rule than optics. Even though these categories are equivalent, it took me a long time to realise the importance of this.</p>
<p>Let’s see how two lenses compose. Suppose we have two lenses <span class="math inline">\((get_1, put_1) : (A, A') \to (B, B')\)</span> and <span class="math inline">\((get_2, put_2) : (B, B') \to (C, C')\)</span>, shown below.</p>
<center>
<img src="../images/lens_precomposed.png" alt="Lens as an optic" width="700" />
</center>
<p>How do we form the composite lens <span class="math inline">\((A, A') \to (C, C')\)</span>? We just plug them together like shown below, right?</p>
<center>
<img src="../images/lens_composed.png" alt="Lens as an optic" width="700" />
</center>
<p>Wrong! What’s drawn above isn’t a lens. Can you spot why? It certainly looks like it should work – it’s simple and elegant. But it’s not a lens. The problem is that the residual <span class="math inline">\(A \times B\)</span> isn’t equal to the top-left input <span class="math inline">\(A\)</span>, which is what a lens requires. Another way to see this is to realise that this lens is of type <span class="math inline">\((A, A') \to (C, C')\)</span> - what are its <span class="math inline">\(get\)</span> and <span class="math inline">\(put\)</span> maps?</p>
<p>Let’s define these <span class="math inline">\(get : A \to C\)</span> and <span class="math inline">\(put : A \times C' \to A'\)</span> maps (forgetting the above image for a moment). The <span class="math inline">\(get : A \to C\)</span> is easy to define - it’s just the composite <span class="math inline">\(get_1 ; get_2 : A \to C\)</span>. But here comes trouble. The <span class="math inline">\(put\)</span> map is more complex. It’s defined as the composite</p>
<center>
<span class="math display">\[A \times C' \xrightarrow{\Delta_A \times C'} A \times A \times C' \xrightarrow{A \times get_1 \times C'} A \times B \times C' \xrightarrow{A \times put_2} A \times B' \xrightarrow{put_1} A'\]</span>
</center>
<p>What happens here is that input <span class="math inline">\(A\)</span> to <span class="math inline">\(put\)</span> is first copied. Then we use one of the copies to obtain a <span class="math inline">\(B\)</span>, which we use in <span class="math inline">\(put_2\)</span>. The map <span class="math inline">\(put_2\)</span> gives us a <span class="math inline">\(B'\)</span>, and then we use <span class="math inline">\(put_1\)</span>, and the other copy of <span class="math inline">\(A\)</span> to obtain <span class="math inline">\(A'\)</span>. If you think about it, you’ll see that this is the only way we could’ve defined it. Let’s draw the result:</p>
<center>
<img src="../images/lens_composed_single.png" alt="Composition of lenses" width="800" />
</center>
<p>This might look a bit strange. It’s different than our original guess, but this really is lens composition. You can convince yourself by tracing out what the grayed out <span class="math inline">\(put\)</span> map does and seeing that it’s the same thing as the equation defined above. We can immediately notice some peculiarities. There’s two <span class="math inline">\(get_1\)</span> maps. The input <span class="math inline">\(A\)</span> is copied twice, not once. To get a better sense of what’s going on, let’s up the stakes. Here’s a composition of <em>three</em> lenses:</p>
<center>
<img src="../images/lens_composed_three.png" alt="Composition of three lenses" width="800" />
</center>
<p>Well, that’s starting to look crowded. There’s 6 <span class="math inline">\(get\)</span> maps now. We’re also copying <span class="math inline">\(A\)</span> three times in total. What’s going on? It looks like composing lenses duplicates one of the <span class="math inline">\(get\)</span> maps (which in this case was itself a composite). This is really inefficient. If we were to use lenses composition in a software project, say for automatic differentiation is some neural network library where layers have millions of parameters - we’d get horrendous performance. In a neural network with <span class="math inline">\(N\)</span> layers, the first one would get recomputed <span class="math inline">\(N\)</span> times. The second one <span class="math inline">\(N - 1\)</span> times, and so on.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> What’s going on? Why is there so much duplication?</p>
<p>All of this happens because of the restriction on the type of the residual in a lens. It can’t be anything other than <span class="math inline">\(A\)</span>, and this prevents the forward pass from sending the result of <span class="math inline">\(get_1\)</span> computation to the backward pass (which is needed as an input to <span class="math inline">\(put_2\)</span>). The backward pass instead needs to redo the work of <span class="math inline">\(get_1\)</span> from the forward pass, and apply it <em>again</em> to <span class="math inline">\(A\)</span>. In other words, we’re computing some things in the forward pass, but the lenses prevent us from using that result in backward pass. The abstraction we chose is working against us. This is bad!</p>
<p>Ideally, we’d like to reuse the answer that <span class="math inline">\(get_1\)</span> computed for <span class="math inline">\(put_2\)</span>, reuse the answer that <span class="math inline">\(get_2\)</span> computed for <span class="math inline">\(put_3\)</span>, and so on. And if we think about it, we realise that this is exactly what our original guess was. Did we absentmindedly create a better answer than what’s in the literature? It turns out that we didn’t discover it - it was already known as <em>optic</em> composition.</p>
<center>
<img src="../images/lens_composed.png" alt="Lens as an optic" width="700" />
</center>
<p>Optic composition (drawn again above) gives us a natural way to compose these bidirectional gadgets. This composite is an optic of type <span class="math inline">\((A, A') \to (C, C')\)</span> where the residual is <span class="math inline">\(M = A \times B\)</span>, the forward map is the composite</p>
<center>
<span class="math display">\[A \xrightarrow{\Delta_A} A \times A \xrightarrow{A \times get_1} A \times B \xrightarrow{A \times \Delta_B} A \times B \times B \xrightarrow{A \times B \times get_2} A \times B \times C\]</span>
</center>
<p>and the backward map is the composite</p>
<center>
<span class="math display">\[A \times B \times C' \xrightarrow{A \times put_2} A \times B' \xrightarrow{put_2} A'\]</span>
</center>
<p>Really, writing things down with equations makes them look more complicated than they are - we’re simply plugging two boxes <a href="https://twitter.com/bgavran3/status/1366202140788731908">side by side</a>, and reading off what we ended up with:</p>
<center>
<img src="../images/optic_comp.gif" alt="Optic composition" width="600" />
</center>
<p>We can notice a few things. There’s no duplication of <span class="math inline">\(get\)</span> maps – everything gets computed exactly once. There’s no need to squeeze anything through the <span class="math inline">\(A\)</span>-shaped internal state – we have the freedom of choosing the type of internal state we need. And the complexity of optic composition is kept at bay – composing optics in sequence causes the residuals to be composed in parallel.</p>
<p>This gives us lots of expressive power, since a complex composition of optics can have a residual that supports this complexity. With lenses the situation is different: we’re fixing a global choice of the residual. And this particular global choice necessitates a specific kind of a composite lens that is always less efficient than its optic counterpart. This is the lens complexity that’s shoved under the rug: lenses seem simpler up-front, but exhibit hidden inefficiencies when you compose them.</p>
<p>In the next section I’ll show how we can model these operational aspects using (2-)category theory.</p>
<h3 id="residual-reification-is-left-adjoint-to-residual-erasure">Residual reification is left adjoint to residual erasure</h3>
<p>This is a short and a relatively technical remark.
The well-known isomorphism of hom-sets <span class="math inline">\(\mathbf{Optic}(\mathcal{C})((A, A'), (B, B')) \cong \mathbf{Lens}(\mathcal{C})((A, A'), (B, B'))\)</span> (as defined in Proposition 2.0.4. in <a href="https://arxiv.org/abs/1809.00738">Categories of Optics</a>) can be weakened into an adjunction. This is because the category <span class="math inline">\(\mathbf{Optic}(\mathcal{C})\)</span> should really be thought of as a 2-category. This 2-category is not anything new, and is already hidden in the plain sight: in the <a href="https://arxiv.org/abs/1809.00738">definition</a> of the 1-category of optics.</p>
<p>Let’s unpack it. This 2-category is going to have the same objects as its one-dimensional counterpart. But morphisms will be slightly different. Recall that a morphism in the 1-category <span class="math inline">\(\mathbf{Optic}(\mathcal{C})\)</span> is <em>an equivalence class</em>. Which equivalence class? The one that identifies optics <span class="math inline">\((M, f, b)\)</span> and <span class="math inline">\((N, f', b')\)</span> to be the same if there is a reparameterisation <span class="math inline">\(r : M \to N\)</span> satisfying some rules. In our 2-category a morphism will be just the triple <span class="math inline">\((M, f, b)\)</span> without any quotienting. And a 2-cell is going to be the said reparameterisation, satisfying the same rules. When defined this way, the job of identifying two optics is left to the higher categorical structure in a natural way. That is, we say two optics are equivalent if there’s an isomorphism <span class="math inline">\((M, f, b) \cong (N, f', b')\)</span>, i.e. two reparameterisations going there and back forming an isomorphism. Compared to the 1-categorical version, we see that we have directionality: having a reparameterisation between two optics doesn’t necessarily mean they’re equivalent. That was the artefact of the need to squish the 2-category down into a 1-category, which is something we don’t want to do. We want to have more expressive power, not less. And interestingly, we’ve already seen an optic 2-cell - it was the <a href="https://twitter.com/bgavran3/status/1484197859205566464">animation</a> at the end of the first section.</p>
<p>Turning <span class="math inline">\(\mathbf{Optic}(\mathcal{C})\)</span> into a 2-category means its hom-sets are now hom-categories, and we can go back to studying the adjunction.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> What are the functors involved?</p>
<p>The functor <span class="math inline">\(U: \mathbf{Optic}(\mathcal{C})((A, A'), (B, B')) \to \mathbf{Lens}(\mathcal{C})((A, A'), (B, B'))\)</span> is the right adjoint.
It takes an optic <span class="math inline">\((M, f, f^{\#}) : (A, A') \to (B, B')\)</span> and creates a lens <span class="math inline">\((f; \pi_2, ((f; \pi_1);B');f^{\#}) : (A, A') \to (B, B')\)</span> by forgetting the residual. The left adjoint <span class="math inline">\(F\)</span> goes the other way and reifies the residual of a lens <span class="math inline">\((get, put) : (A, A') \to (B, B')\)</span>, creating an optic <span class="math inline">\((A, \Delta_A ; (A \times get), put)\)</span>.</p>
<p>If we do a roundtrip <span class="math inline">\(U;F\)</span>, starting from the optic <span class="math inline">\((M, f, f^{\#})\)</span> we turn that optic into its lens form <span class="math inline">\((A, \Delta_A;(A \times f;\pi_2), ((f;\pi_1)\times B) ; f^{\#})\)</span>. But this technically isn’t the <em>same</em> optic we started with - there’s a 2-cell from the latter to the former which is the counit of this adjunction. Proving this takes some work, but this is the main idea.
It tells us that erasing the residual is a functor that has a left adjoint – the one that reifies this notion of a residual in a canonical way.</p>
<center>
<img src="../images/optic_adjoint.png" alt="Lens as an optic" width="700" />
</center>
<p>The story goes deeper. Previously I referred to the equivalence of categories <span class="math inline">\(\mathbf{Lens}(\mathcal{C}) \cong \mathbf{Optic}(\mathcal{C})\)</span>. This equivalence is denotational, and doesn’t see the operational aspects we talked about. But these operational aspects start to be visible categorically after we turn optics into a 2-category. We no longer have an equivalence of categories, and we no longer have a functor <span class="math inline">\(\mathbf{Lens}(\mathcal{C}) \to \mathbf{Optic}(\mathcal{C})\)</span>. Instead, we have an <em>oplax</em> functor <span class="math inline">\(\mathbf{Lens}(\mathcal{C}) \to \mathbf{Optic}(\mathcal{C})\)</span>. This oplax functor captures the idea that lenses compose differently than optics. The oplax structure tells us that composing two lenses and turning the result into an optic <em>does not</em> give us the same result as turning these two lenses individually into optics, and then composing the result.</p>
<p>This is a striking result, but it’s for another time.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Bidirectional processes are all around us. They embody essential notions of what it means to be an agent in a world: to act, receive feedback, and update ourselves. Even though we often model these processes as black-box systems, a lot of practical considerations depend on their internals. It is therefore paramount to have expressive models that allow us to describe all the nuances we need.</p>
<p>By modelling these systems with lenses we relinquish our ability to model those internals. This doesn’t mean the internal state isn’t there – it’s there, and it still affects what we do. We just lack the conceptual tools to talk about it.</p>
<p>With optics we get these conceptual tools. We get the expressive power to describe this internal state, and say what happens to it as we compose optics in various ways. In a way, by using optics we didn’t really add any complexity – we just distilled what was already there, and gave it a name.
This is the idea behind a lot of category theory too – to distill what is already there, and give it a name.</p>
<h3 id="some-more-ponderings">Some more ponderings:</h3>
<ul>
<li>Everything described here for lenses applies to all coend optics: prisms, affine traversals, grates, and so on. It would be interesting to unpack the operational aspect of each one.</li>
<li>What I described here applies to <em>cartesian lenses</em>. It would be interesting to understand how the story changes when applied to dependent lenses. Of course, understanding what dependent optics are is an open research question, and the topic of our recent <a href="https://arxiv.org/abs/2112.11145">arXiv preprint</a>.</li>
</ul>
<p><br>
<br></p>
<p>Thanks to <a href="https://matteocapucci.wordpress.com/">Matteo Capucci</a> for insightful conversations and help in checking technical details, and <a href="https://ievacepaite.com/">Ieva Čepaitė</a> for a read-through of this post.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>This is the <em>concrete</em> presentation of a lens. There’s a few more encodings (such as the van Laarhoven encoding), but they’re not the focus of this blog post.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>The first symbol is the copy map <span class="math inline">\(\Delta_A : A \to A \times A\)</span> which duplicates the input (drawn as a black dot in the diagrams). I’m using <span class="math inline">\(;\)</span> to denote diagrammatic composition, i.e. <span class="math inline">\(f;g = g \circ f\)</span>. And when I write <span class="math inline">\(A\)</span> on an arrow, this means I’m talking about the identity morphism <span class="math inline">\(id_A : A \to A\)</span>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>This is precisely what Conal Elliott noticed in <a href="https://arxiv.org/abs/1804.00746">Simple Essence of Automatic Differentiation</a>. He noticed that standard lens composition duplicates data, and is horribly inefficient. He then proposes a switch to <em>linear lenses</em>, which are just another example of an optic. It’s interesting to note that he doesn’t use the terminology of lenses or optics at all, but this is essentially what a part of his paper is about.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>We consider <span class="math inline">\(\mathbf{Lens}(\mathcal{C})\)</span> as a 2-category too, but the trivial one which only has identity 2-cells.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

<div class="commentbox"></div>


<script>
commentBox('5769281040023552-proj');
</script>

        <div id="footer">
          <div class="inside">
            Licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/"> CC BY-SA 4.0</a>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
            The theme originates in the <a href="http://katychuang.com/hakyll-cssgarden/gallery/">Hakyll-CSSGarden</a>.
          </div>
        </div>

          </div>
        </div>
    </body>
</html>
